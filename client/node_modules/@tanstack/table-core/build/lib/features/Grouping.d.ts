import { RowModel } from '..';
import { BuiltInAggregationFn } from '../aggregationFns';
import { TableFeature } from '../core/table';
import { Cell, Column, OnChangeFn, Table, Row, Updater, ColumnDefTemplate, RowData, AggregationFns } from '../types';
export type GroupingState = string[];
export interface GroupingTableState {
    grouping: GroupingState;
}
export type AggregationFn<TData extends RowData> = (columnId: string, leafRows: Row<TData>[], childRows: Row<TData>[]) => any;
export type CustomAggregationFns = Record<string, AggregationFn<any>>;
export type AggregationFnOption<TData extends RowData> = 'auto' | keyof AggregationFns | BuiltInAggregationFn | AggregationFn<TData>;
export interface GroupingColumnDef<TData extends RowData, TValue> {
    aggregationFn?: AggregationFnOption<TData>;
    aggregatedCell?: ColumnDefTemplate<ReturnType<Cell<TData, TValue>['getContext']>>;
    enableGrouping?: boolean;
    getGroupingValue?: (row: TData) => any;
}
export interface GroupingColumn<TData extends RowData> {
    getCanGroup: () => boolean;
    getIsGrouped: () => boolean;
    getGroupedIndex: () => number;
    toggleGrouping: () => void;
    getToggleGroupingHandler: () => () => void;
    getAutoAggregationFn: () => AggregationFn<TData> | undefined;
    getAggregationFn: () => AggregationFn<TData> | undefined;
}
export interface GroupingRow {
    groupingColumnId?: string;
    groupingValue?: unknown;
    getIsGrouped: () => boolean;
    getGroupingValue: (columnId: string) => unknown;
    _groupingValuesCache: Record<string, any>;
}
export interface GroupingCell {
    getIsGrouped: () => boolean;
    getIsPlaceholder: () => boolean;
    getIsAggregated: () => boolean;
}
export interface ColumnDefaultOptions {
    onGroupingChange: OnChangeFn<GroupingState>;
    enableGrouping: boolean;
}
interface GroupingOptionsBase {
    manualGrouping?: boolean;
    onGroupingChange?: OnChangeFn<GroupingState>;
    enableGrouping?: boolean;
    getGroupedRowModel?: (table: Table<any>) => () => RowModel<any>;
    groupedColumnMode?: false | 'reorder' | 'remove';
}
type ResolvedAggregationFns = keyof AggregationFns extends never ? {
    aggregationFns?: Record<string, AggregationFn<any>>;
} : {
    aggregationFns: Record<keyof AggregationFns, AggregationFn<any>>;
};
export interface GroupingOptions extends GroupingOptionsBase, ResolvedAggregationFns {
}
export type GroupingColumnMode = false | 'reorder' | 'remove';
export interface GroupingInstance<TData extends RowData> {
    setGrouping: (updater: Updater<GroupingState>) => void;
    resetGrouping: (defaultState?: boolean) => void;
    getPreGroupedRowModel: () => RowModel<TData>;
    getGroupedRowModel: () => RowModel<TData>;
    _getGroupedRowModel?: () => RowModel<TData>;
}
export declare const Grouping: TableFeature;
export declare function orderColumns<TData extends RowData>(leafColumns: Column<TData, unknown>[], grouping: string[], groupedColumnMode?: GroupingColumnMode): Column<TData, unknown>[];
export {};
