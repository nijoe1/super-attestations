{"version":3,"file":"column.js","sources":["../../../src/core/column.ts"],"sourcesContent":["import {\n  Column,\n  Table,\n  AccessorFn,\n  ColumnDef,\n  RowData,\n  ColumnDefResolved,\n} from '../types'\nimport { memo } from '../utils'\n\nexport interface CoreColumn<TData extends RowData, TValue> {\n  id: string\n  depth: number\n  accessorFn?: AccessorFn<TData, TValue>\n  columnDef: ColumnDef<TData, TValue>\n  columns: Column<TData, TValue>[]\n  parent?: Column<TData, TValue>\n  getFlatColumns: () => Column<TData, TValue>[]\n  getLeafColumns: () => Column<TData, TValue>[]\n}\n\nexport function createColumn<TData extends RowData, TValue>(\n  table: Table<TData>,\n  columnDef: ColumnDef<TData, TValue>,\n  depth: number,\n  parent?: Column<TData, TValue>\n): Column<TData, TValue> {\n  const defaultColumn = table._getDefaultColumnDef()\n\n  const resolvedColumnDef = {\n    ...defaultColumn,\n    ...columnDef,\n  } as ColumnDefResolved<TData>\n\n  const accessorKey = resolvedColumnDef.accessorKey\n\n  let id =\n    resolvedColumnDef.id ??\n    (accessorKey ? accessorKey.replace('.', '_') : undefined) ??\n    (typeof resolvedColumnDef.header === 'string'\n      ? resolvedColumnDef.header\n      : undefined)\n\n  let accessorFn: AccessorFn<TData> | undefined\n\n  if (resolvedColumnDef.accessorFn) {\n    accessorFn = resolvedColumnDef.accessorFn\n  } else if (accessorKey) {\n    // Support deep accessor keys\n    if (accessorKey.includes('.')) {\n      accessorFn = (originalRow: TData) => {\n        let result = originalRow as Record<string, any>\n\n        for (const key of accessorKey.split('.')) {\n          result = result?.[key]\n          if (process.env.NODE_ENV !== 'production' && result === undefined) {\n            console.warn(\n              `\"${key}\" in deeply nested key \"${accessorKey}\" returned undefined.`\n            )\n          }\n        }\n\n        return result\n      }\n    } else {\n      accessorFn = (originalRow: TData) =>\n        (originalRow as any)[resolvedColumnDef.accessorKey]\n    }\n  }\n\n  if (!id) {\n    if (process.env.NODE_ENV !== 'production') {\n      throw new Error(\n        resolvedColumnDef.accessorFn\n          ? `Columns require an id when using an accessorFn`\n          : `Columns require an id when using a non-string header`\n      )\n    }\n    throw new Error()\n  }\n\n  let column: CoreColumn<TData, any> = {\n    id: `${String(id)}`,\n    accessorFn,\n    parent: parent as any,\n    depth,\n    columnDef: resolvedColumnDef as ColumnDef<TData, any>,\n    columns: [],\n    getFlatColumns: memo(\n      () => [true],\n      () => {\n        return [\n          column as Column<TData, TValue>,\n          ...column.columns?.flatMap(d => d.getFlatColumns()),\n        ]\n      },\n      {\n        key: process.env.NODE_ENV === 'production' && 'column.getFlatColumns',\n        debug: () => table.options.debugAll ?? table.options.debugColumns,\n      }\n    ),\n    getLeafColumns: memo(\n      () => [table._getOrderColumnsFn()],\n      orderColumns => {\n        if (column.columns?.length) {\n          let leafColumns = column.columns.flatMap(column =>\n            column.getLeafColumns()\n          )\n\n          return orderColumns(leafColumns)\n        }\n\n        return [column as Column<TData, TValue>]\n      },\n      {\n        key: process.env.NODE_ENV === 'production' && 'column.getLeafColumns',\n        debug: () => table.options.debugAll ?? table.options.debugColumns,\n      }\n    ),\n  }\n\n  column = table._features.reduce((obj, feature) => {\n    return Object.assign(obj, feature.createColumn?.(column, table))\n  }, column)\n\n  // Yes, we have to convert table to uknown, because we know more than the compiler here.\n  return column as Column<TData, TValue>\n}\n"],"names":["createColumn","table","columnDef","depth","parent","_ref","_resolvedColumnDef$id","defaultColumn","_getDefaultColumnDef","resolvedColumnDef","accessorKey","id","replace","undefined","header","accessorFn","includes","originalRow","result","key","split","_result","process","env","NODE_ENV","console","warn","Error","column","String","columns","getFlatColumns","memo","_column$columns","flatMap","d","debug","_table$options$debugA","options","debugAll","debugColumns","getLeafColumns","_getOrderColumnsFn","orderColumns","_column$columns2","length","leafColumns","_table$options$debugA2","_features","reduce","obj","feature","Object","assign"],"mappings":"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"}